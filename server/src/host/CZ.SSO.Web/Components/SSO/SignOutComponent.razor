@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

<link rel="stylesheet" href="/signout.css" />

<div class="container">
    <div class="signout-container">
        <div class="logo">
            <img src="@GetIconPath("blog.svg")" class="icon icon-blog" alt="Blog icon">
            <span>@Translations["brand-name"]</span>
        </div>
        
        <div class="signout-card">
            <div class="signout-icon">
                <img src="@GetIconPath("sign-out.svg")" class="icon icon-sign-out" alt="Sign out icon">
            </div>
            
            <h1>@Translations["signout-title"]</h1>
            <p>@Translations["signout-message"]</p>
            
            <div class="signout-actions">
                <button id="confirmSignout" class="btn btn-primary" @onclick="ConfirmSignout" disabled="@isProcessing">
                    @if (isProcessing)
                    {
                        <span>@Translations["confirm-signout"]...</span>
                    }
                    else
                    {
                        <span>@Translations["confirm-signout"]</span>
                    }
                </button>
                <button id="cancelSignout" class="btn btn-secondary" @onclick="CancelSignout" disabled="@isProcessing">@Translations["cancel"]</button>
            </div>
            
            <div class="signout-info">
                <p>@Translations["signed-in-as"]</p>
                <p class="user-email">@userEmail</p>
            </div>
        </div>
        
        <div class="controls-switcher">
            <button id="langToggle" class="toggle-btn" @onclick="ToggleLanguage">@currentLang.ToUpper()</button>
            <button id="themeToggle" class="toggle-btn" @onclick="ToggleTheme">
                <img src="@GetThemeIconPath()" class="icon icon-sun" alt="Theme toggle">
            </button>
        </div>
    </div>
</div>

@if (showNotification)
{
    <div class="notification @notificationType">
        @notificationMessage
    </div>
}

<style>
    /* CSS styles will be added here */
</style>

@code {
    private string currentLang = "en";
    private string currentTheme = "light";
    private string userEmail = "user@example.com";
    private bool isProcessing = false;
    private bool showNotification = false;
    private string notificationMessage = "";
    private string notificationType = "info";
    
    private Dictionary<string, string> Translations = new();
    
    protected override async Task OnInitializedAsync()
    {
        await LoadTranslations();
        await LoadPreferences();
        await LoadUserInfo();
    }
    
    private async Task LoadTranslations()
    {
        // Default English translations
        Translations = new Dictionary<string, string>
        {
            { "brand-name", "MyBlog" },
            { "signout-title", "Sign Out" },
            { "signout-message", "Are you sure you want to sign out of your account?" },
            { "confirm-signout", "Sign Out" },
            { "cancel", "Cancel" },
            { "signed-in-as", "Signed in as:" },
            { "signout-success", "You have been successfully signed out." },
            { "signout-error", "An error occurred while signing out. Please try again." },
            { "redirecting", "Redirecting to home page..." }
        };
        
        // If language is Chinese, update translations
        if (currentLang == "zh")
        {
            Translations = new Dictionary<string, string>
            {
                { "brand-name", "我的博客" },
                { "signout-title", "退出登录" },
                { "signout-message", "您确定要退出登录吗？" },
                { "confirm-signout", "退出登录" },
                { "cancel", "取消" },
                { "signed-in-as", "当前登录账户：" },
                { "signout-success", "您已成功退出登录。" },
                { "signout-error", "退出登录时发生错误，请重试。" },
                { "redirecting", "正在跳转到首页..." }
            };
        }
        
        StateHasChanged();
    }
    
    private async Task LoadPreferences()
    {
        try
        {
            // Load saved preferences from localStorage via JS interop
            currentLang = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "preferred-language") ?? "en";
            currentTheme = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "preferred-theme") ?? "light";
            
            await LoadTranslations();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading preferences: {ex.Message}");
            // Set default values if JS interop fails
            currentLang = "en";
            currentTheme = "light";
            await LoadTranslations();
        }
    }
    
    private async Task LoadUserInfo()
    {
        try
        {
            // In a real app, this would come from the authentication service
            userEmail = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "userEmail") ?? "user@example.com";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading user info: {ex.Message}");
            // Set default value if JS interop fails
            userEmail = "user@example.com";
        }
    }
    
    private async Task ToggleLanguage()
    {
        try
        {
            currentLang = currentLang == "en" ? "zh" : "en";
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "preferred-language", currentLang);
            await LoadTranslations();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error toggling language: {ex.Message}");
            await LoadTranslations();
        }
    }
    
    private async Task ToggleTheme()
    {
        try
        {
            currentTheme = currentTheme == "light" ? "dark" : "light";
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "preferred-theme", currentTheme);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error toggling theme: {ex.Message}");
            StateHasChanged();
        }
    }
    
    private string GetThemeIconPath()
    {
        return GetIconPath(currentTheme == "light" ? "sun.svg" : "moon.svg");
    }
    
    private string GetIconPath(string iconName)
    {
        return $"./icons/{currentTheme}/{iconName}";
    }
    
    private async Task ConfirmSignout()
    {
        isProcessing = true;
        
        try
        {
            // In a real app, this would call the authentication service
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "authToken");
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "userEmail");
            
            // Show success notification
            ShowNotification(Translations["signout-success"], "success");
            
            // Show redirecting notification and redirect
            await Task.Delay(1000);
            ShowNotification(Translations["redirecting"], "info");
            
            await Task.Delay(1500);
            NavigationManager.NavigateTo("/signin");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during signout: {ex.Message}");
            ShowNotification(Translations["signout-error"], "error");
            // Fallback: try to redirect even if localStorage operations fail
            await Task.Delay(1000);
            NavigationManager.NavigateTo("/signin");
        }
        finally
        {
            isProcessing = false;
        }
    }
    
    private void CancelSignout()
    {
        // In a real app, this would redirect back to the previous page or dashboard
        ShowNotification("Redirecting back...", "info");
        
        // For demo purposes, we'll just navigate to home
        NavigationManager.NavigateTo("/");
    }
    
    private void ShowNotification(string message, string type = "info")
    {
        notificationMessage = message;
        notificationType = type;
        showNotification = true;
        
        // Hide notification after 3 seconds
        Task.Delay(3000).ContinueWith(_ =>
        {
            showNotification = false;
            StateHasChanged();
        });
        
        StateHasChanged();
    }
}